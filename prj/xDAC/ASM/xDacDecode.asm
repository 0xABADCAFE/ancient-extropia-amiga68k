;///////////////////////////////////////////////////////////////////////////////////
;//
;//	 XDAC::DecodeFrames()
;//
;//  Bulk code generated by compiler. Hand optimised inner loops to improve speed
;//
;//  Principal optimisations
;//
;//  Removed all temp copies of this->
;//    move a6,ax; move (ax),.. >>> move (a6),...
;//
;//  Eliminated temps in evaluation of inner vars, eg mask, bitRate etc, assigned
;//  to regs
;//
;///////////////////////////////////////////////////////////////////////////////////

; Storm C Compiler
; Mendoza:Extropia/eXtropia/prj/xDAC/xDacDecode.cpp
	mc68040

	XREF	Zero__MEM__PvUi
	XREF	Frame__XDAC__Tj

	SECTION "_0ct__streampos__T:0",CODE
	rts

	SECTION "DecodeFrames__XDAC__TPsjj:0",CODE
	XDEF	DecodeFrames__XDAC__TPsjj

DecodeFrames__XDAC__TPsjj


L130	EQU	-$50
	link	a5,#L130
	movem.l	d2-d7/a2/a3/a6,-(a7)
	movem.l	$10(a5),d0/d2
	move.l	$C(a5),a2
	move.l	$8(a5),a6

L99
;//	if (!num)
	tst.l	d2
	bne.b	L101


L100
;//	num = shared.numFrames;
	move.l	$20(a6),d2

L101
;//	if (start)
	tst.l	d0
	beq.b	L103


L102
;//	Frame(start);
	move.l	d0,-(a7)
	move.l	a6,-(a7)
	jsr	Frame__XDAC__Tj
	addq.w	#$8,a7


L103
;//	if (shared.channels==1)
	move.w	$26(a6),d0
	cmp.w	#1,d0
	bne	L114


L104
;//	d = dest;
;//	n = num+1;
	move.l	d2,d0
	addq.l	#1,d0
	move.l	d0,-4(a5)

;//	while(--n)
	bra	L112


L105
;//	c = *current++;
	move.l	$34(a6),a1
	lea	2(a1),a0
	move.l	a0,$34(a6)

	move.w	(a1),d2
;//	d2 == header
;//	if (XDAC_SILENCE(c))
	moveq	#0,d0
	move.w	d2,d0
	and.l	#$8000,d0
	beq.b	L107


L106
;//	f = XDAC_SLNC_LEN(c);
	moveq	#0,d0
	move.w	d2,d0
	and.l	#$FFF,d0
	move.w	d0,d3

;//	s = shared.frameLen*f;
	move.w	$24(a6),d2
	mulu	d3,d2

;//	MEM::Zero(d,s);
	move.l	d2,-(a7)
	move.l	a2,-(a7)
	jsr	Zero__MEM__PvUi
	addq.w	#$8,a7

;//	d += s;
	move.l	d2,d0
	moveq	#1,d2
	asl.l	d2,d0
	add.l	d0,a2

;//	n -= (f-1);
	moveq	#0,d0
	move.w	d3,d0
	subq.l	#1,d0
	sub.l	d0,-4(a5)
	bra	L112

;////////////////////////////////////////////////////////////////////////////////////////////
;//
;//	Hand optimised code for inner loop listed below
;//	{
;//		rsint16		bitRate = XDAC_BITRATE(c);
;//		ruint16		mask		= (1<<bitRate)-1;
;//		rsint16		shiftMx	= ((8*sizeof(sint16))/bitRate);
;//		rsint16		shifted	= shiftMx;
;//		rsint16 	sample	= *((sint16*)current++);
;//		rsint16*	qTable	= (sint16*)current;
;//		ruint16*	cmpDat	= current+XDAC_TABLESIZE(c);
;//		*d++ = (sint16)sample;
;//		ruint16 packed = *cmpDat++;
;//		rsint16	i = shared.frameLen;
;//		while(--i)
;//		{
;//			sample += qTable[(packed & mask)];
;//			*d++ = sample;
;//			packed >>= bitRate;
;//			if (--shifted==0)
;//			{
;//				shifted = shiftMx;
;//				packed = *cmpDat++;
;//			}
;//		}
;//	}
;//
;// frame constants
;//	d5 == bitRate
;//	d6 == mask
;//	d7 == shiftMx
;//
;//	frame vars
;//	d0 == packed
;//	d1 == shifted
;//	d2 == scratch/frame Header
;//	d3 == sample
;//	d4 == sample counter
;//
;//	my pointers
;//	a0 == cmpDat
;// a1 == scratch
;//	a2 == dest
;//	a3 == qTable
;//
;// compiler/machine pointers
;// a5 == stack frame
;// a6 == this
;// a7 == usp/ssp
;//
;////////////////////////////////////////////////////////////////////////////////////////////

L107

;//	bitRate = XDAC_BITRATE(c) -> d5 (32)
	move.w	d2,d5
	and.w	#$300,d5
	lsr.w	#8,d5
	addq.w	#2,d5
	ext.l	d5

;//	mask = (1<<bitRate)-1 -> d6 (32)
	moveq	#1,d6
	lsl.l	d5,d6
	subq.l	#1,d6

;//	shiftMx	= ((8*sizeof(sint16))/bitRate) -> d7 (32)
	moveq	#$10,d7
	divu	d5,d7
	ext.l	d7;

;//	shifted	= shiftMx	-> d1 (16)
	move.w	d7,d1

;//	sample	= *((sint16*)current++); -> d3 (16)

	move.l	$34(a6),a1
	lea	2(a1),a0
	move.l	a0,$34(a6)

	move.w	(a1),d3

;//	qTable	= (sint16*)current; -> a3
	movea.l $34(a6), a3;

;//	cmpDat	= current+XDAC_TABLESIZE(c)
	move.w	d2,d0
	and.w	#$1F,d0
	lea	2(a3,d0.w*2),a0 ; // Check that for a CISC addressing mode

;//	*d++ = (sint16)sample;
	move.w	d3,(a2)+

;//	packed = *cmpDat++ -> d0
	move.w	(a0)+,d0

;//	i = shared.frameLen -> d4
	move.w	$24(a6),d4

;//	while(--i)
	bra.b	L110

;//	 done with d2==frame header
;//	 d2 == scratch reg

L108
;//	sample += qTable[(packed & mask)];

	move.w	d0,d2
	and.w	d6,d2; packed & mask -> d2

	add.w	(a3,d2.w*2),d3;	d3 += qTable[(packed & mask)]

;//	*d++ = sample;
	move.w	d3,(a2)+

;//	packed(d0) >>= bitRate(d5);
	lsr.w	d5,d0

;//	if (--shifted==0)
	subq.w	#1,d1
	tst.w	d1
	bne.b	L110


L109
;//	shifted = shiftMx;
	move.w	d7,d1

;//	packed = *cmpDat++;
	move.w	(a0)+,d0


;// d4 == sample number
L110
	subq.w	#1,d4
	tst.w	d4
	bne.b	L108

L111
;	current = cmpDat;
	move.l	a0,$34(a6)

;	frameNum++;
	move.l	$38(a6),d0
	addq.l	#1,d0
	move.l	d0,$38(a6)


L112
	subq.l	#1,-4(a5)
	tst.l	-4(a5)
	bne	L105


L113
	moveq	#0,d0
	movem.l	(a7)+,d2-d7/a2/a3/a6
	unlk	a5
	rts

;////////////////////////////////////////////////////////////////////////////////////////
;//
;//	 Multiple channel decode
;//  Currently, per frame channel spec is not implemented
;//
;//  This code has to put more than one variable in a register to avoid critical memory
;//  reads
;//
;////////////////////////////////////////////////////////////////////////////////////////

L114
;//	rsint16* d = dest;
;//	rsint32	n = num+1;
	move.l	d2,d0
	addq.l	#1,d0
	move.l	d0,-4(a5)

;//	channels in d3 msw
	move.w	$26(a6),d3;
	swap	d3

;// frame lenngth in d7 msw
;	move.w	$24(a6), d7
;	swap	d7

;//	while(--n)
	bra	L128

L115
;//	c = *current++;
;//	frame header,c, in d3 lsw (channels in msw)

	move.l	$34(a6),a1
	lea	2(a1),a0
	move.l	a0,$34(a6)

	move.w	(a1),d3

;//	if (XDAC_SILENCE(c))
	moveq	#0,d0
	move.w	d3,d0
	and.l	#$8000,d0
	beq.b	L117

L116
;//	ruint16 f = XDAC_SLNC_LEN(c);
;// We only need the silent frame count, so just keep it in d3 lsw
	and.w	#$FFF,d3


;//	rsint32 s = shared.frameLen*shared.channels*f;
	move.w	$24(a6),d2
	mulu	d3,d2	;// f*shared.frameLen -> d2
	swap d3			;// channels in d3 lsw
	mulu	d3,d2	;// channels*(f*shared.frameLen) -> d2
	swap d3			;// put channels back in d3 msw, silent frames back in lsw

;//	MEM::Zero(d,s);
	move.l	d2,-(a7)
	move.l	a2,-(a7)
	jsr	Zero__MEM__PvUi
	addq.w	#$8,a7

;//	d += s;
	move.l	d2,d0
	moveq	#1,d2
	asl.l	d2,d0
	add.l	d0,a2

;//	n -= (f-1);
	moveq	#0,d0
	move.w	d3,d0
	subq.l	#1,d0
	sub.l	d0,-4(a5)
	bra	L128

L117
;//	for (rsint16 chan=0, *s=sample; chan<shared.channels,...

	swap d3; // channels in d3 lsw
	moveq	#0,d0
	lea	-$1A(a5),a1
	bra.b	L119

L118
;//	*d++ = *s++ = *((sint16*)current)++;
	move.l	$34(a6),-$3C(a5)
	move.l	-$3C(a5),a0
	lea	2(a0),a0
	move.l	a0,$34(a6)
	move.l	-$3C(a5),a0
	move.w	(a0),d1
	move.w	d1,(a1)+
	move.w	d1,(a2)+
	addq.w	#1,d0

L119
;	move.w	d0,d2
;	ext.l	d2
;	moveq	#0,d1

;	move.w	$26(a6),d1
;	cmp.l	d1,d2

	cmp.w	d3,d0
	blt.b	L118

	swap d3;	// channels back in d3 msw, frame header in lsw

;/////////////////////////////////////////////////////////////////////////////
;//
;//  OPTIMISE THIS
;//
;//  Put inner loop counters into regs. Share i / chan as 16:16 ?
;//  Currently, only chan in reg.
;//
;/////////////////////////////////////////////////////////////////////////////

;// frame constants
;// d5 == mask
;//	d6 == bitRate
;//	d7 == shiftMx : sample counter
;//
;//	frame vars
;//	d0 == sample counter : channel counter (16:16)
;//	d1 == packed
;//	d2 == shifted
;//	d3 == frame header/sample : num channels
;//	d4 == scratch
;//
;//	my pointers
;//	a0 == cmpDat
;// a1 == &sample[...]
;//	a2 == dest
;//	a3 == qTable
;//
;// compiler/machine pointers
;// a5 == stack frame
;// a6 == this
;// a7 == usp/ssp

L120
;// frame header, c, in lsw of d3, shared.channels in msw of d3
;//	bitRate	= XDAC_BITRATE(c);
	move.w	d3,d6
	and.w	#$300,d6
	lsr.w	#8,d6
	addq.w	#2,d6
	ext.l	d6

;//	mask		= (1<<bitRate)-1;
	moveq	#1,d5
	lsl.l	d6,d5
	subq.l	#1,d5

;//	shiftMx	= ((8*sizeof(sint16))/bitRate); -> d7 lsw
	moveq	#$10,d7
	divu	d6,d7
	ext.l	d7;

;//	shifted	= shiftMx;
	move.w	d7,d2

;//	*qTable	= (sint16*)current; -> a3
	movea.l	$34(a6), a3

;//	*cmpDat	= current+XDAC_TABLESIZE(c);
	move.w	d3,d0
	and.w	#$1F,d0
	lea	2(a3,d0.w*2),a0 ; // Check that for a CISC addressing mode

;//	packed	= *cmpDat++;
	move.w	(a0)+,d1

;//	i = shared.frameLen;
;// put i in lsw d0 for outer loop, swap to msw for inner and use lsw as chan count
	move.w	$24(a6), d0

;//	while (--i)
	bra.b	L126

L121

;//	d0 currently has i in lsw, swap into msw and use lsw for channel counter
;//	for (chan=0; chan<shared.channels; chan++)

;//	&sample[0] -> a1
	lea -$1A(a5),a1

	swap 	d0
	clr.w	d0
	bra.b	L125

L122
;//	Were finished using the frame header now, so we can re use the lsw of d3 for
;// the current sample, leaving the total channels in the msw
;//	rsint16 s = sample[chan] + qTable[(packed&mask)];
;//	sample[chan] -> d3
	move.w	(a1), d3

;//	packed d1 -> d4
	move.w	d1,d4


;//	packed & mask ->d4
	and.w	d5,d4

;//	qTable[(packed&mask)] -> d4
	move.w	(a3,d4.w*2),d4

;//	sample[chan] + qTable...
	add.w	d4,d3

;//	*d++ = sample[chan] = s;
;//	...sample[chan] = ... Increment pointer to reflect chan++
	move.w	d3,(a1)+

;//	*d++ = ...
	move.w	d3,(a2)+

;//	packed >>= bitRate;
	lsr.w	d6,d1

;//	if (--shifted==0)
	subq.w	#1,d2
	tst.w	d2
	bne.b	L124

L123
;//	shifted = shiftMx;
	move.w	d7,d2

;//	packed = *cmpDat++;
	move.w	(a0)+,d1

;// chan++
L124
	addq.w	#1,d0

;// chan<shared.channels
L125
	move.l	d3, d4; // channels ->d4 msw, avoid having to re swap d3 later
	swap	d4;		//
	cmp.w	d4, d0; // compare with counter
	blt.b	L122

;//	inner channel loop has ended, so need to restore i in lsw of d0 for outer loop now
;// d0 -> i
	swap d0

L126
;//	d0 lsw currently contains i
;// --i
	subq.w	#1, d0
	tst.w	d0
	bne.b	L121

L127
;//	current = cmpDat;
	move.l	a0,$34(a6)

;//	frameNum++;
	move.l	$38(a6),d0
	addq.l	#1,d0
	move.l	d0,$38(a6)

L128
	subq.l	#1,-4(a5)
	tst.l	-4(a5)
	bne	L115

L129
	moveq	#0,d0
	movem.l	(a7)+,d2-d7/a2/a3/a6
	unlk	a5
	rts

	END
